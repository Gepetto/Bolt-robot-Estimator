import sys
sys.path.append('/home/nalbrecht/Bolt-Estimator/Bolt-robot---Estimator/src/python')
import numpy as np
from scipy.spatial.transform import Rotation as R


from Bolt_Utils import Log
from Graphics import Graphics
from Bolt_Estimator_0 import Estimator
from DeviceEmulator import DeviceEmulator
from TrajectoryGenerator import TrajectoryGenerator
from Bolt_Filter_Complementary import ComplementaryFilter
sys.path.append('/home/nalbrecht/Bolt-Estimator/Bolt-robot---Estimator/data')
from DataReader import DataReader



def main():
    N = 1000 - 1
    T = 1
    dt = 5e-3
    kf=4

    # create objects
    testlogger = Log("test", PrintOnFlight=True)
    grapher = Graphics(logger=testlogger)
    generator = TrajectoryGenerator(logger=testlogger)
    device = DeviceEmulator(TrajectoryGenerator=generator, logger=testlogger)
    reader = DataReader(logger=testlogger)

    # load traj generated by simulation 
    device.LoadSimulatedData(Reader=reader, kfile=kf)
    # init estimator
    estimator = Estimator(device=device,
                    ModelPath="",
                    UrdfPath="",
                    Talkative=True,
                    logger=testlogger,
                    AttitudeFilterType = "complementary",
                    parametersAF = [2],
                    SpeedFilterType = "complementary",
                    parametersSF = [2],
                    TimeStep = dt,
                    IterNumber = N)
    
    # plot the pseudo-measured (eg noisy and drifting) generated trajectories
    traj, speed, acc = device.GetTranslation()
    Inputs_translations = [traj.T, speed.T, acc.T]
    theta, omega, omegadot = device.GetRotation()
    Inputs_rotations = [theta.T, omega.T]

    True_LCF = reader.Get("lcf")
    """
    grapher.SetLegend(["traj", "speed", "acc"], 3)
    grapher.CompareNDdatas(Inputs_translations, "", "Trajectory, speed and acceleration as inputed", StyleAdapter=False, width=1.)

    grapher.SetLegend(["theta", "omega"], 3)
    grapher.CompareNDdatas(Inputs_rotations, "", "rotation and rotation speed as inputed", StyleAdapter=False, width=1.)
    """
    
    # run the estimator as if
    # device will iterate over generated data each time estimator calls it
    for j in range(N-1):
        estimator.Estimate()
        #print(f'iter : {j}')
    
    # get logs from estimator
        # rotations
    Qtheta_estimator = estimator.Get("theta_logs")
    Qtheta_imu = estimator.Get("theta_logs_imu")
    
    # get logs from contact estimator
        # contact forces
    LCF_1D, RCF_1D = estimator.ContactEstimator.Get("cf_1d")
    LCF_3D, RCF_3D = estimator.ContactEstimator.Get("cf_3d")
    LCF_T, RCF_T = estimator.ContactEstimator.Get("cf_torques")
        # trust etc
    Trust = estimator.ContactEstimator.Get("trust")
    Slip = estimator.ContactEstimator.Get("slip_prob")
    Contact = estimator.ContactEstimator.Get("contact_bool")
    ContactProb = estimator.ContactEstimator.Get("contact_prob")
    ContactProb_F = estimator.ContactEstimator.Get("contact_prob_force")
    ContactProb_T = estimator.ContactEstimator.Get("contact_prob_torque")
    
    
    # convert and plot
        # rotation to euler angles
    theta_estimator = np.zeros((3, N))
    theta_imu = np.zeros((3, N))
    for j in range(N-1):
        theta_estimator[:, j] = R.from_quat(Qtheta_estimator[:, j]).as_euler('xyz')
        theta_imu[:, j] = R.from_quat(Qtheta_imu[:, j]).as_euler('xyz')
        

    
    """
    # plot rotation
    InOut_rotations = [theta.T[:2, :], theta_imu[:2, :], theta_estimator[:2, :]]
    grapher.SetLegend(["theta in", "theta imu","theta out"], 2)
    grapher.CompareNDdatas(InOut_rotations, "theta", "Noisy rot and out rot", StyleAdapter=True, width=1.)
    
    # plot base acceleration with and without gravity
    ag = device.AccG
    a = device.Acc
    grapher.SetLegend(["ag", "a"], 3)
    grapher.CompareNDdatas([ag.T, a.T], "acceleration", "g", StyleAdapter=True, width=1.)
    """
    
    # plot true base trajectory
    #reader.PlotBaseTrajectory()
    
    # plot true base torques
    #reader.PlotLeftFootCorrelation()
    
    # plot contact forces
    """
    grapher.SetLegend(["Left force from 1D",], ndim=3)
    grapher.CompareNDdatas([LCF_1D], datatype='force', title='1D left contact force')
    
    grapher.SetLegend(["Left force from 3D",], ndim=3)
    grapher.CompareNDdatas([LCF_3D], datatype='force', title='3D left contact force')
    grapher.SetLegend(["Left force from torques",], ndim=3)
    grapher.CompareNDdatas([LCF_T], datatype='force', title='torque left contact force')
    
    grapher.SetLegend(["Right force from 1D",], ndim=3)
    grapher.CompareNDdatas([RCF_1D], datatype='force', title='1D right contact force')
    
    grapher.SetLegend(["Right force from 3D",], ndim=3)
    grapher.CompareNDdatas([RCF_3D], datatype='force', title='3D right contact force')
    grapher.SetLegend(["Right force from torques",], ndim=3)
    grapher.CompareNDdatas([RCF_T], datatype='force', title='torque right contact force')

    grapher.SetLegend(["Left force from 3D", "Left force from torques", "Right force from 3D", "Right force from torques",], ndim=1)
    grapher.CompareNDdatas([LCF_3D[2:, :], LCF_T[2:, :], RCF_3D[2:, :], RCF_T[2:, :]], datatype='force', title='comparing contact force')
    """
    print(True_LCF)
    grapher.SetLegend(["Left Z force from 3D", "Left X force from 3D", "Left force from torques", "True left Force"], ndim=1)
    grapher.CompareNDdatas([LCF_3D[2:, :], LCF_3D[:1, :], LCF_T[2:, :], [True_LCF[:N, 2]]], datatype='force', title='comparing contact force', mitigate=[1])
    """
    
    L3DNorm = np.linalg.norm(LCF_3D, axis=0)
    R3DNorm = np.linalg.norm(RCF_3D, axis=0)

    grapher.SetLegend(["Left force from 3D", "Left force from torques", "Right force from 3D", "Right force from torques",], ndim=1)
    grapher.CompareNDdatas([[L3DNorm], LCF_T[2:, :], [R3DNorm], RCF_T[2:, :]], datatype='force', title='comparing contact force TOTAL')
    
    toto = np.array(toto)
    grapher.SetLegend(["Torques"], ndim=6)
    grapher.CompareNDdatas([toto.transpose()], datatype='torque', title='Torques', StyleAdapter=True)
    
    # plot trust, slips and contact
    grapher.SetLegend(["Slip","Trust"], ndim=2)
    grapher.CompareNDdatas([Slip, Trust], datatype='real value', title='probability of slip and trust value')
    """

    grapher.SetLegend(["Contact boolean"], ndim=2)
    grapher.CompareNDdatas([Contact], datatype='proba', title='contact')
    

    grapher.SetLegend(["Contact probability", "Contact probability Force", "Contact probability Torque", ], ndim=1)
    grapher.CompareNDdatas([ContactProb[:1, :], ContactProb_F[:1, :], ContactProb_T[:1, :]], datatype='proba', title='probability of left contact')
    
    """
    grapher.SetLegend(["Contact probability force 3d", "Z Force"], ndim=1)
    grapher.CompareNDdatas([5*ContactProb_F[:1, :], LCF_3D[2:, :]], datatype='proba', title='probability of left contact')
    """
    
    grapher.end()
    return None



















def main_fakedata():
    N = 5000
    T = 10

    # init updates
    testlogger = Log("test", PrintOnFlight=True)
    grapher = Graphics(logger=testlogger)
    generator = TrajectoryGenerator(logger=testlogger)
    device = DeviceEmulator(TrajectoryGenerator=generator, logger=testlogger)

    # generate traj
    device.GenerateTrajectory(N=N, NoiseLevelXY=10, NoiseLevelZ=10, Drift=30, NoiseLevelAttitude=10, T=T)
    # init estimator
    estimator = Estimator(device=device,
                    ModelPath="",
                    UrdfPath="",
                    Talkative=True,
                    logger=testlogger,
                    AttitudeFilterType = "complementary",
                    parametersAF = [2],
                    SpeedFilterType = "complementary",
                    parametersSF = [2],
                    TimeStep = T/N,
                    IterNumber = N)
    
    # plot the pseudo-measured (eg noisy and drifting) generated trajectories
    traj, speed, acc = device.GetTranslation()
    Inputs_translations = [traj.T, speed.T, acc.T]
    theta, omega, omegadot = device.GetRotation()
    Inputs_rotations = [theta.T, omega.T]

    grapher.SetLegend(["traj", "speed", "acc"], 3)
    grapher.CompareNDdatas(Inputs_translations, "", "Trajectory, speed and acceleration as inputed", StyleAdapter=False, width=1.)

    grapher.SetLegend(["theta", "omega"], 3)
    grapher.CompareNDdatas(Inputs_rotations, "", "rotation and rotation speed as inputed", StyleAdapter=False, width=1.)

    
    
    # run the estimator as if
    # device will iterate over generated data each time estimator calls it
    for j in range(N-1):
        estimator.Estimate()
    
    # get data as quat
    Qtheta_estimator = estimator.Get("theta_logs")
    Qtheta_imu = estimator.Get("theta_logs_imu")
    theta_estimator = np.zeros((3, N))
    theta_imu = np.zeros((3, N))
    for j in range(N-1):
        theta_estimator[:, j] = R.from_quat(Qtheta_estimator[:, j]).as_euler('xyz')
        theta_imu[:, j] = R.from_quat(Qtheta_imu[:, j]).as_euler('xyz')
    
    InOut_rotations = [theta.T[:2, :], theta_imu[:2, :], theta_estimator[:2, :]]
    grapher.SetLegend(["theta in", "theta imu","theta out"], 2)
    grapher.CompareNDdatas(InOut_rotations, "theta", "Noisy rot and out rot", StyleAdapter=True, width=1.)
    
    ag = device.AccG
    a = device.Acc
    grapher.SetLegend(["ag", "a"], 3)
    grapher.CompareNDdatas([ag.T, a.T], "acceleration", "g", StyleAdapter=True, width=1.)

    '''

    filter = ComplementaryFilter(ndim=3, parameters=[T/N, 2])
    theta_filter = np.zeros((3, N))

    # run filter over time, with noisy data as inputs
    for k in range(N):
        theta_filter[:, k] = filter.RunFilter(theta.T[:,k], omega.T[:,k])
    
    InOut_rotations = [theta.T[:2, :], theta_filter[:2, :]]
    grapher.SetLegend(["theta in","theta filter"], 2)
    grapher.CompareNDdatas(InOut_rotations, "theta", "theta", StyleAdapter=True, AutoLeg=False, width=1.)
    
    '''

    grapher.end()
    return None









if __name__ == "__main__":
    main()













