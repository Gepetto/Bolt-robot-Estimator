import sys
sys.path.append('/home/nalbrecht/Bolt-Estimator/Bolt-robot---Estimator/src/python')
import numpy as np
from scipy.spatial.transform import Rotation as R


from Bolt_Utils import Log
from Graphics import Graphics
from Bolt_Estimator_0 import Estimator
from DeviceEmulator import DeviceEmulator
from TrajectoryGenerator import TrajectoryGenerator
from Bolt_Filter_Complementary import ComplementaryFilter
sys.path.append('/home/nalbrecht/Bolt-Estimator/Bolt-robot---Estimator/data')
from DataReader import DataReader



def main():
    N = 100
    T = 10
    dt = 1e-2
    kf=6

    # create objects
    testlogger = Log("test", PrintOnFlight=True)
    grapher = Graphics(logger=testlogger)
    generator = TrajectoryGenerator(logger=testlogger)
    device = DeviceEmulator(TrajectoryGenerator=generator, logger=testlogger)
    reader = DataReader(logger=testlogger)

    # load traj generated by simulation 
    device.LoadSimulatedData(Reader=reader, kfile=kf)
    # init estimator
    estimator = Estimator(device=device,
                    ModelPath="",
                    UrdfPath="",
                    Talkative=True,
                    logger=testlogger,
                    AttitudeFilterType = "complementary",
                    parametersAF = [2],
                    SpeedFilterType = "complementary",
                    parametersSF = [2],
                    TimeStep = dt,
                    IterNumber = N)
    
    # plot the pseudo-measured (eg noisy and drifting) generated trajectories
    traj, speed, acc = device.GetTranslation()
    Inputs_translations = [traj.T, speed.T, acc.T]
    theta, omega, omegadot = device.GetRotation()
    Inputs_rotations = [theta.T, omega.T]

    grapher.SetLegend(["traj", "speed", "acc"], 3)
    grapher.CompareNDdatas(Inputs_translations, "", "Trajectory, speed and acceleration as inputed", StyleAdapter=False, width=1.)

    grapher.SetLegend(["theta", "omega"], 3)
    grapher.CompareNDdatas(Inputs_rotations, "", "rotation and rotation speed as inputed", StyleAdapter=False, width=1.)

    
    
    # run the estimator as if
    # device will iterate over generated data each time estimator calls it
    for j in range(N-1):
        estimator.Estimate()
    
    # get logs from estimator
        # rotations
    Qtheta_estimator = estimator.Get("theta_logs")
    Qtheta_imu = estimator.Get("theta_logs_imu")
    
    # get logs from contact estimator
        # contact forces
    LCF_1D, RCF_1D = estimator.ContactEstimator.Get("cf_1d")
    LCF_3D, RCF_3D = estimator.ContactEstimator.Get("cf_3d")
    LCF_T, RCF_T = estimator.ContactEstimator.Get("cf_torques")
        # trust etc
    Trust = estimator.ContactEstimator.Get("trust")
    Slip = estimator.ContactEstimator.Get("slip_prob")
    Contact = estimator.ContactEstimator.Get("contact_bool")
    ContactProb = estimator.ContactEstimator.Get("contact_prob")
    
    
    # convert and plot
        # rotation to euler angles
    theta_estimator = np.zeros((3, N))
    theta_imu = np.zeros((3, N))
    for j in range(N-1):
        theta_estimator[:, j] = R.from_quat(Qtheta_estimator[:, j]).as_euler('xyz')
        theta_imu[:, j] = R.from_quat(Qtheta_imu[:, j]).as_euler('xyz')
    
    
    # plot rotation
    InOut_rotations = [theta.T[:2, :], theta_imu[:2, :], theta_estimator[:2, :]]
    grapher.SetLegend(["theta in", "theta imu","theta out"], 2)
    grapher.CompareNDdatas(InOut_rotations, "theta", "Noisy rot and out rot", StyleAdapter=True, width=1.)
    
    # plot base acceleration with and without gravity
    ag = device.AccG
    a = device.Acc
    grapher.SetLegend(["ag", "a"], 3)
    grapher.CompareNDdatas([ag.T, a.T], "acceleration", "g", StyleAdapter=True, width=1.)
    
    # plot true base trajectory
    reader.PlotBaseTrajectory()
    
    # plot true base torques
    reader.PlotLeftFootCorrelation()
    
    # plot contact forces
    grapher.SetLegend(["Left force from 1D",], ndim=3)
    grapher.CompareNDdatas([LCF_1D], datatype='force', title='1D left contact force')
    grapher.SetLegend(["Left force from 3D",], ndim=3)
    grapher.CompareNDdatas([LCF_3D], datatype='force', title='3D left contact force')
    grapher.SetLegend(["Left force from torques",], ndim=3)
    grapher.CompareNDdatas([LCF_T], datatype='force', title='torque left contact force')

    grapher.SetLegend(["Right force from 1D",], ndim=3)
    grapher.CompareNDdatas([RCF_1D], datatype='force', title='1D right contact force')
    grapher.SetLegend(["Right force from 3D",], ndim=3)
    grapher.CompareNDdatas([RCF_3D], datatype='force', title='3D right contact force')
    grapher.SetLegend(["Right force from torques",], ndim=3)
    grapher.CompareNDdatas([RCF_T], datatype='force', title='torque right contact force')
    
    # plot trust, slips and contact
    grapher.SetLegend(["Slip","Trust"], ndim=2)
    grapher.CompareNDdatas([Slip, Trust], datatype='real value', title='probability of slip and trust value')
    
    grapher.SetLegend(["Contact boolean"], ndim=2)
    grapher.CompareNDdatas([Contact], datatype='proba', title='contact')
    grapher.SetLegend(["Contact probability"], ndim=2)
    grapher.CompareNDdatas([ContactProb], datatype='proba', title='probability of contact')
    grapher.end()
    return None



















def main_fakedata():
    N = 5000
    T = 10

    # init updates
    testlogger = Log("test", PrintOnFlight=True)
    grapher = Graphics(logger=testlogger)
    generator = TrajectoryGenerator(logger=testlogger)
    device = DeviceEmulator(TrajectoryGenerator=generator, logger=testlogger)

    # generate traj
    device.GenerateTrajectory(N=N, NoiseLevelXY=10, NoiseLevelZ=10, Drift=30, NoiseLevelAttitude=10, T=T)
    # init estimator
    estimator = Estimator(device=device,
                    ModelPath="",
                    UrdfPath="",
                    Talkative=True,
                    logger=testlogger,
                    AttitudeFilterType = "complementary",
                    parametersAF = [2],
                    SpeedFilterType = "complementary",
                    parametersSF = [2],
                    TimeStep = T/N,
                    IterNumber = N)
    
    # plot the pseudo-measured (eg noisy and drifting) generated trajectories
    traj, speed, acc = device.GetTranslation()
    Inputs_translations = [traj.T, speed.T, acc.T]
    theta, omega, omegadot = device.GetRotation()
    Inputs_rotations = [theta.T, omega.T]

    grapher.SetLegend(["traj", "speed", "acc"], 3)
    grapher.CompareNDdatas(Inputs_translations, "", "Trajectory, speed and acceleration as inputed", StyleAdapter=False, width=1.)

    grapher.SetLegend(["theta", "omega"], 3)
    grapher.CompareNDdatas(Inputs_rotations, "", "rotation and rotation speed as inputed", StyleAdapter=False, width=1.)

    
    
    # run the estimator as if
    # device will iterate over generated data each time estimator calls it
    for j in range(N-1):
        estimator.Estimate()
    
    # get data as quat
    Qtheta_estimator = estimator.Get("theta_logs")
    Qtheta_imu = estimator.Get("theta_logs_imu")
    theta_estimator = np.zeros((3, N))
    theta_imu = np.zeros((3, N))
    for j in range(N-1):
        theta_estimator[:, j] = R.from_quat(Qtheta_estimator[:, j]).as_euler('xyz')
        theta_imu[:, j] = R.from_quat(Qtheta_imu[:, j]).as_euler('xyz')
    
    InOut_rotations = [theta.T[:2, :], theta_imu[:2, :], theta_estimator[:2, :]]
    grapher.SetLegend(["theta in", "theta imu","theta out"], 2)
    grapher.CompareNDdatas(InOut_rotations, "theta", "Noisy rot and out rot", StyleAdapter=True, width=1.)
    
    ag = device.AccG
    a = device.Acc
    grapher.SetLegend(["ag", "a"], 3)
    grapher.CompareNDdatas([ag.T, a.T], "acceleration", "g", StyleAdapter=True, width=1.)

    '''

    filter = ComplementaryFilter(ndim=3, parameters=[T/N, 2])
    theta_filter = np.zeros((3, N))

    # run filter over time, with noisy data as inputs
    for k in range(N):
        theta_filter[:, k] = filter.RunFilter(theta.T[:,k], omega.T[:,k])
    
    InOut_rotations = [theta.T[:2, :], theta_filter[:2, :]]
    grapher.SetLegend(["theta in","theta filter"], 2)
    grapher.CompareNDdatas(InOut_rotations, "theta", "theta", StyleAdapter=True, AutoLeg=False, width=1.)
    
    '''

    grapher.end()
    return None









if __name__ == "__main__":
    main()













